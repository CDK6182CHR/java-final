# 量子葫芦娃大战-Java课程设计

* 姓名：马兴越
* 学号：171870660
* 院系：现代工程与应用科学学院
* JDK版本：JDK1.80_221
* 主类：`top.xep0268.calabashes.Main`



## 概要

首先给出的是整体的界面布置。操作方法和要求文档中的一致。本项目的主体部分是从第四次作业拷贝过来的，但本文档是重写的。为了完整起见，仍然第4次作业中涉及的部分进行说明，但不作为重点。

程序启动后首先展示启动界面，此界面保留大约1秒。

<img src="img/cover.png" alt="cover" style="zoom:50%;" />

然后进入主界面，双方列队。此时可以按空格开始战斗，或者按`L`读取记录文件来回放。战斗过程中，生物体按照一定逻辑移动（后面详述），当两个生物体进入8邻域内相邻时，则二者中有一个会死亡，死亡概率由**量子力学**原理计算导出（狗头x）。死亡的生物体变成“横着的”，并且颜色变为黑白。

如下图所示是程序主界面。左侧是战场，以深浅不同、互相交错的灰色标记，每一时刻每一格内至多有一个生物；右侧是战况的概要，其中“事件表”列出了所有生物杀死的事件及其发生的时间（从按下空格键开始计时，以毫秒为单位）；下面的“葫芦娃”和“妖精”两栏的`ListView`显示双方当前存活的生物。

<img src="img/battle.png" alt="main" style="zoom:50%;" />

当一方生物全部死亡后，则弹出对话框提示哪一方获胜。点击“确定”关闭对话框后，战场重新布局。

<img src="img/dialog.png" alt="dialog" style="zoom:50%;" />

### 核心设定

我们对战场的物理环境和生物能力做如下的规定。

1. 生物在场地中的移动只能**逐步**完成，且每一步只能在**八邻域**意义下相邻的两格之间移动。我们规定，在布阵时，生物体之间可以交换位置；但在战斗开始后，生物体只能移动到一个空位中。

2. 战斗开始后，生物以（看起来）类似时钟同步的方式进行移动，每个“时钟周期”内只能移动一步（上一条所规定的意义下的一步）。

   > 需说明，此处“时钟同步”只是个表象。实际上，每个生物体是独立的线程，只是在每次更新后`sleep`一个周期长度（规定在`Game.INTERVAL`）。

3. 生物体相遇时候的死亡概率由二者所处时空位置波函数模方的相对大小决定，具体表达形式和推导详见附录部分。



## 结构设计

由于整个项目涉及的类比较多，一张类图画不下，所以我们拆分成多个类图来展示。

首先要给出的是**抽象层**总体布局类图。这张类图主要精确到抽象类、接口层次，并列出了必要的实体类。程序中与异常相关的`exceptions`包没有列在类图上。

![abstract](img/main.png)

现在在package的层次上简单说明整个程序的顶层设计。

* `items`包，是所有生物体类所在的包。抽象类`Item`是逻辑意义上的生物体，剥离了图形界面部分；其抽象子类`Living`主要是添加了图形界面的支持。所有的真实生物，都是`Living`的子类。`Leader`接口是领导排队的生物。
* `field`包。主要包含与场地实现有关的类。类`Block`表示逻辑意义上的一个单元格，场地`Field`是其集合；`Position`类属于生物对象，记录该生物所处位置。
* `formations`包，包括对阵型的支持。主要有抽象的阵型类`Formation`和布阵的泛型处理类`FormationHandler`。
* `log`包，是记录与读取记录的支持。程序中的事件都是`AbstractEvent`的子类，通过`EventWriter`和`EventReader`进行写入和读取。
* 基本包。主要是游戏进行的逻辑支持。`Game`包含启动、布阵的基本逻辑，`Judger`和`JudgeHandler`主要以类似消息队列的方式处理生物发生冲突的事件（决定谁死谁活）。`Game`是最顶层的类；`Main`没有列出。

大多数的与图形界面相关的类，采用**继承**的方法实现。即，创建一个逻辑上的基本类，例如`Block`，其中不包括图形界面，可以单独测试核心逻辑；再创建其子类，加入对图形界面的支持。为了实现好这部分逻辑，用了较多的泛型。

## 代码设计

这部分将逐个包、逐个类说明其设计和重要的逻辑，并阐明所遵循的**设计原则**和使用的**设计模式**。

### `items`包

首先给出这部分的详细类图。图中没有画出注解类。

<img src="img/items.png" alt="items" style="zoom:50%;" />

#### `Item`类

这个类实际上对应于前几次作业中的`Living`类，包含了其中的大多数逻辑。`Item`类含有一个`Position`对象，记录当前`Item`所处的位置。`Item`类中实现了生物体的移动`move`和寻路`pathTo`方法，这部分在前几次作业的报告中已经详细地说明过了，这里不再赘述。这里重点讨论多线程的支持。

##### 多线程

`Item`是`java.util.concurrent.Thread`的子类。用一个标志位`inVideo`标示是否处于回放模式下。重写的`run()`方法分成两种情况。

**第一**，当系统处在运行模式（即按空格后）时，调用`live()`方法。每隔一个时钟周期（定义在`Game.INTERVAL`常量中），执行一次更新。每次更新随机地选取一个敌对生物作为攻击目标，以倾向于该生物所在方向的一个随机方向前进一步。

> 说明两点：
>
> 1. “倾向于该生物所在方向的一个随机方向”，是指主体生物随机向八邻域内某个方向走一步，但走到目标生物方向的概率最大。
> 2. 之所以不采用确定的算法（即：直接向该生物所在方向走一步），一方面是因为这样将导致游戏结束太快，另一方面是因为在两生物之间有特定结构的障碍物的情况下，容易造成死循环。另一方面，之所以不采用完全随机的算法，是因为这样将导致进行到最后（只剩少数几个生物）的时候，敌对双方很难遇到，很久不能结束。

完成一步后，检查其八邻域内是否有敌对生物。如果有敌对生物，则将自身与对方加入判断队列中（实际上是执行`Game.decide()`方法）。

**第二**，当生物处在回放模式时，目前的实现里，生物线程并不需要做什么事情。

当生物死亡时，由`Game`调用`die()`方法，将`active`标志位置为`false`，并中止当前线程。

##### 抽象方法

线程更新中，查找敌人和判断邻域敌人的方法，需要使用依赖`Game`对象，所以使用抽象方法实现，属于**模版方法**设计模式。整个`Item`类的核心原则是与`Game`和图形界面元素解耦，这体现了**接口隔离原则**。

#### `Living`类

这是`Item`类的图形界面版本。程序中真实的生物都是其子类。本类具有一个`Pane`成员，主要时有一个`ImageView`组件，其内容是生物的图片，从资源文件中读取。当生物移动时，除调用基类方法外，还要写入记录；当生物死亡时，还要更新图片为死亡生物的图片。

在程序中的绝大多数地方，都采用`Living`和`Item`引用，而非具体的生物实体类。大多数的程序都仅依赖于`Living`类，这自然体现了**依赖倒置原则**和**李氏替换法则**。

#### `Leader`接口

`Leader`接口是与布阵有关的接口。凡是指挥布阵的生物，都实现这个接口。接口只有一个泛型方法，

```java
<T extends Formation> void embattleFormation(Class<T> formType)
            throws NoSpaceForFormationException;
```

当需要布阵时，从生物调用这个方法，方法内部使用`FormationHandler`来实现布阵。

#### `Elder`类

生物体的具体实现类大多是平凡的。这里以老人家类（`Elder`）为例，说明与具体实现相关的一些事情。

在每个实体类中，实现基类的抽象方法`getResourceName`，利用动态绑定，获得生物的图片文件名来加载。这是模版方法的一个实例。

##### 生物阵营的标记

生物阵营的标记是采用**注解**(Annotation)实现的。对于葫芦娃阵营的生物，用注解`@WithCalabash`来标记；对于妖精阵营的，用`WithDemon`来标记。在系统判断何方获胜时，利用反射机制，获取注解来判断阵营。

#### `PassedFlag`

最后说明一下`PassedFlag`类。这是主程序中，`Item`实体子类中唯一一个不继承`Living`的，仅仅是个逻辑上的场地上元素。它的作用是，在**寻路**过程中，复用`Field`部分的代码，作为已经走过的单元格的标记。寻路算法详见前几次作业的报告。

逻辑上，虽然看起来比较奇怪，这样的设计也是有合理之处的。我们并没有说，`PassedFlag`是一种生物，而只是说它是，逻辑上的，场地上的元素。只是这里的“场地”并非是实体的场地（后面将说到的`BattleField`），而只是一个抽象的场地，罢了。

### `field`包

`field`包的内容是所有对场地部分的支持。首先是本包内部的详细类图

<img src="img/field.png" alt="field" style="zoom:50%;" />

#### `Block`类

这是本次课程设计编码中新增加的一层抽象，表示一个只能站立至多一个生物的单元格。这是一个**泛型**类，其模版参数是`<T extends Item>`，即元素类型，在具体的实现中只需精确到`Living`即可。这里使用泛型是为了让`Field` - `Block` - `Item` 三个层次之间实现**协变**，也就是能创建出，仅逻辑上的`Field`和支持图形界面的`Field`。

##### 线程安全

需修改状态的两个方法，即`setLiving()`和`removeLiving()`都采用了`synchronized`同步方法，这样使得同一个单元格同一时间只能由一个生物体修改其状态。

#### `GraphicBlock`类

是`Block<Living>`的子类。相比`Block`，主要是多了图形部分`Pane`，且当单元格状态变化时，同步修改图形部分。

#### `Field`类

这个类的逻辑和前几次作业中的`Field`基本一样，但改为了泛型类。泛型参数是`<T extends Block>`，即单元格类型。由于需要创建`T`类型的对象，需要利用**反射**机制，在本类的构造方法中接受一个`Class<T>`类型的参数，私有方法`T instanceBlock(int i, int j)`逻辑上相当于`new`。

与生物体移动、增加、删除有关的方法全部复用了前几次作业中的方法，不再赘述。

#### `BattleField`

前述的`Field`类是逻辑上的战场，而`BattleField`是游戏中采用的战场，采用**单例类**设计模式。本类是`Field<GraphicBlock>`的子类。

这里补充说明一下逻辑意义上的`Field`类的意义了。程序中有两个地方用到了，

* 在寻路算法的实现中，记录已走过的地方的时候，相当于使用了`Field<Block<PassedFlag>>`。
* 在单元测试中，用于测试基本逻辑，而不借助图形界面。

#### `BattleGridPane`

